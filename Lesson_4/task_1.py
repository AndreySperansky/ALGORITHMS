import timeit

import math


"""
1. Проанализировать скорость и сложность одного любого алгоритма,
разработанных в рамках домашнего задания первых трех уроков.
Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.

Подсказка:
1) возьмите 2-3 задачи, реализованные ранее, сделайте замеры на разных входных данных
2) сделайте для каждой из задач оптимизацию (придумайте что можно оптимизировать)
и также выполните замеры на уже оптимизированных алгоритмах
3) опишите результаты - где, что эффективнее и почему.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО


**********************************  Задача_1 *************************************************
Определить, какое число в массиве встречается чаще всего
Подсказка: можно применить ф-цию MAX_ с параметром key
"""

SETUP_1 = '''
from random import randint
LST_LEN = 10
ARR = [randint(0, 80) for i in range(LST_LEN)]
'''



# 1a) Кондовое решение тупо в лоб через цикл без какой-либо оптимизации

STMT_1 = '''
ARR_SET = set(ARR)  # Получаем только уникальные элементы
MAX = None  # Наиболее частый элемент
MAX_COUNT = 0  # Его количество

for item in ARR_SET:
    qty = ARR.count(item)
    if qty > MAX_COUNT:
        MAX_COUNT = qty
        MAX = item
'''


print(timeit.timeit(setup=SETUP_1, stmt=STMT_1, number=10000 ))

# 1b)  Вариант оптимизации посредством отказа от лишней операции приведения
STMT_2 = '''
MAX_1 = ARR[0]
MAX_COUNT_1 = ARR.count(MAX_1)

for el in ARR:
    if ARR.count(el) > MAX_COUNT_1:
        MAX_1 = el
        MAX_COUNT_1 = ARR.count(el)
'''

print(timeit.timeit(setup=SETUP_1, stmt=STMT_2, number=10000 ))

# 1с) вариант  оптимизации с использованием max() и генератора списка

STMT_3 = "MAX_COUNT_2 = max([(i, ARR.count(i)) for i in set(ARR)], key=lambda t: t[1])"

print(timeit.timeit(setup=SETUP_1, stmt=STMT_3, number=10000 ))

# 1d) вариант  оптимизации с использованием sorted() и генератора списка

STMT_4 = "MAX_COUNT_3 = sorted([(i, ARR.count(i)) for i in set(ARR)], key=lambda t: t[1])[-1]"

print(timeit.timeit(setup=SETUP_1, stmt=STMT_4, number=10000 ))

# Результат для списка из 20 элементов
# 0.101019036
# 0.11336512700000001
# 0.13346065199999996
# 0.15419179100000002


# Результат для списка из 125 элементов:
# 1.601363601
# 3.152487656
# 1.5972672990000003
# 1.5417390319999997


# Результат для списка из 500 элементов:
# 7.983416481
# 47.995709788
# 7.963553353999998
# 8.050154505000002



"""
Результаты замеров эффективности алгоритмов для разной длины списков очевидным образом показывают,
что  использование представления списков (list comprehension) зависит напрямую от количества
элементов списка:
сначала эффективность растет а потом снова падает. Связано это с тем, что списки это целый кусок
памяти и при добавлении нового элемента в конец интерпритатор запрашивает новый кусок памяти
и переписывает туда весь список за O(n).




*************************************** Задача 2 ***************************************************

3.	Сформировать из введенного числа обратное по порядку входящих в него
цифр и вывести на экран. Например, если введено число 3486,
то надо вывести число 6843.

Подсказка:
Используйте арифм операции для формирования числа, обратного введенному

Пример:
Введите число: 123
Перевернутое число: 321

"""


def reverse_cyc(NUM):
    '''
    function for to reverse a number
    :param num_rev: a num meant to reverse
    :return: reversed number
    '''
    num_rev = 0
    while NUM > 0:
        digit = NUM % 10
        NUM = NUM // 10
        num_rev *= 10
        num_rev = num_rev + digit
    return num_rev


try:
    NUM = abs(int(input("Введите число: ")))
    print(f"Реверсное число равно: {reverse_cyc(NUM)}")
except ValueError:
    print('Ошибка, нужно ввести целое число!')


# Оптимизация с помощью рекурсии


def rec_reverse(num_rev):
    '''
    function for to reverse a number
    :param num_rev: a num meant to reverse
    :return: reversed number
    '''
    if num_rev < 10:
        return num_rev
    return (num_rev % 10) * 10 ** (int(math.log(num_rev, 10))) + rec_reverse(num_rev // 10)


try:
    NUM = int(input('Введите целое число: '))
    REV_NUM = rec_reverse(NUM)
    print(REV_NUM)
except ValueError:
    print('Ошибка, нужно ввести целое число!')


def recur_reverse(num, flip = 0):
    if num == 0:
        return flip
    else:
        flip = (flip * 10) + (num % 10)
        num = num // 10
        return recur_reverse(num, flip)


try:
    NUM = int(input('Введите целое число: '))
    REV_NUM = recur_reverse(NUM)
    print(REV_NUM)
except ValueError:
    print('Ошибка, нужно ввести целое число!')
    
    
print(timeit.timeit("reverse_cyc(123456)", setup="from __main__ import reverse_cyc"))

print(timeit.timeit("rec_reverse(123456)", setup="from __main__ import rec_reverse"))

print(timeit.timeit("recur_reverse(123456, flip = 0)", setup="from __main__ import recur_reverse"))

# 1.5510712700000004        Циклическая (линейная сложность)
# 5.281020649               Рекурсивная экспоненциальная сложность O(10^n)
# 2.3367640859999987        Рекурсивная

'''
Результаты замеров эффективности алгоритмов для разной длины списков очевидным образом показывают, что
наихудший результат продемонстрировал алгоритм с использованием рекурсии и возведения в степень
в следствие чего алгоритм получил экспоненциальную сложность , в то время
как алгоритм без рекрсивного вызова функции показал наилучший результат в следствие линейной
сложности алгоритма. Между ними по оценке эффективности находится рекурсивный алгоритм без использования
операции возведения в степень, уступающий победителю из-за записи и чтения стека памяти
то есть если цикл имеет сложность O(n) то рекурсия если она, к примеру, вызывется 4 раза
будет иметь сложность 4n a если вызывется n раз то
сложность может повысится до O(n^2). Ну, насколько я понял...
'''
